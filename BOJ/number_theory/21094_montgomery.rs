use std::io::Write;

use num::{Montgomery, PowBy};

mod simple_io {
    pub struct InputAtOnce<'a> {
        _buf: String,
        iter: std::str::SplitAsciiWhitespace<'a>,
    }

    impl<'a> InputAtOnce<'a> {
        pub fn token(&mut self) -> &'a str {
            self.iter.next().unwrap_or_default()
        }

        pub fn value<T: std::str::FromStr>(&mut self) -> T
        where
            T::Err: std::fmt::Debug,
        {
            self.token().parse().unwrap()
        }
    }

    pub fn stdin_at_once<'a>() -> InputAtOnce<'a> {
        let _buf = std::io::read_to_string(std::io::stdin()).unwrap();
        let iter = _buf.split_ascii_whitespace();
        let iter = unsafe { std::mem::transmute(iter) };
        InputAtOnce { _buf, iter }
    }

    pub fn stdout() -> std::io::BufWriter<std::io::Stdout> {
        std::io::BufWriter::new(std::io::stdout())
    }
}

pub mod num {
    pub trait ModOp<T> {
        fn zero(&self) -> T;
        fn one(&self) -> T;
        fn modulus(&self) -> T;
        fn add(&self, lhs: T, rhs: T) -> T;
        fn sub(&self, lhs: T, rhs: T) -> T;
        fn mul(&self, lhs: T, rhs: T) -> T;
    }

    pub trait PowBy<T, E> {
        fn pow(&self, base: T, exp: E) -> T;
    }

    pub trait InvOp<T> {
        fn inv(&self, n: T) -> T;
    }

    impl<T: Clone, M: ModOp<T>> PowBy<T, u32> for M {
        fn pow(&self, mut base: T, mut exp: u32) -> T {
            let mut res = self.one();
            while exp > 0 {
                if exp % 2 == 1 {
                    res = self.mul(res, base.clone());
                }
                base = self.mul(base.clone(), base);
                exp >>= 1;
            }
            res
        }
    }

    impl<T: Clone, M: ModOp<T>> PowBy<T, u64> for M {
        fn pow(&self, mut base: T, mut exp: u64) -> T {
            let mut res = self.one();
            while exp > 0 {
                if exp % 2 == 1 {
                    res = self.mul(res, base.clone());
                }
                base = self.mul(base.clone(), base);
                exp >>= 1;
            }
            res
        }
    }

    impl<M: ModOp<u32>> InvOp<u32> for M {
        fn inv(&self, n: u32) -> u32 {
            self.pow(n, self.modulus() - 2)
        }
    }

    impl<M: ModOp<u64>> InvOp<u64> for M {
        fn inv(&self, n: u64) -> u64 {
            self.pow(n, self.modulus() - 2)
        }
    }

    // Montgomery reduction
    #[derive(Debug, Clone)]
    pub struct Montgomery<T> {
        m: T,
        m_inv: T,
        r2: T,
    }

    impl Montgomery<u32> {
        pub fn new(m: u32) -> Self {
            debug_assert!(m % 2 == 1, "modulus must be coprime with 2");
            let mut m_inv = 1u32;
            for _ in 0..5 {
                m_inv = m_inv.wrapping_mul(2u32.wrapping_sub(m.wrapping_mul(m_inv)));
            }
            let r = m.wrapping_neg() % m;
            let r2 = (r as u64 * r as u64 % m as u64) as u32;

            Self { m, m_inv, r2 }
        }

        fn reduce_double(&self, x: u64) -> u32 {
            debug_assert!((x as u64) < (self.m as u64) * (self.m as u64));
            let q = (x as u32).wrapping_mul(self.m_inv);
            let a = ((q as u64 * self.m as u64) >> 32) as u32;
            let mut res = (x >> 32) as u32 + self.m - a;
            if res >= self.m {
                res -= self.m;
            }
            res as u32
        }

        pub fn reduce(&self, x: u32) -> u32 {
            self.reduce_double(x as u64)
        }

        pub fn transform(&self, x: u32) -> u32 {
            debug_assert!(x < self.m);
            self.mul(x, self.r2)
        }
    }

    impl ModOp<u32> for Montgomery<u32> {
        fn zero(&self) -> u32 {
            0
        }
        fn one(&self) -> u32 {
            self.transform(1)
        }
        fn modulus(&self) -> u32 {
            self.m
        }
        fn mul(&self, x: u32, y: u32) -> u32 {
            debug_assert!(x < self.m);
            debug_assert!(y < self.m);
            self.reduce_double(x as u64 * y as u64)
        }

        fn add(&self, x: u32, y: u32) -> u32 {
            debug_assert!(x < self.m);
            debug_assert!(y < self.m);
            let sum = x + y;
            if sum >= self.m {
                sum - self.m
            } else {
                sum
            }
        }

        fn sub(&self, x: u32, y: u32) -> u32 {
            debug_assert!(x < self.m);
            debug_assert!(y < self.m);
            if x >= y {
                x - y
            } else {
                x + self.m - y
            }
        }
    }

    impl Montgomery<u64> {
        pub fn new(m: u64) -> Self {
            debug_assert!(m % 2 == 1, "modulus must be coprime with 2");
            let mut m_inv = 1u64;
            for _ in 0..6 {
                // More iterations may be needed for u64 precision
                m_inv = m_inv.wrapping_mul(2u64.wrapping_sub(m.wrapping_mul(m_inv)));
            }
            let r = m.wrapping_neg() % m;
            let r2 = (r as u128 * r as u128 % m as u128) as u64;

            Self { m, m_inv, r2 }
        }

        pub fn reduce_double(&self, x: u128) -> u64 {
            debug_assert!((x as u128) < (self.m as u128) * (self.m as u128));
            let q = (x as u64).wrapping_mul(self.m_inv);
            let a = ((q as u128 * self.m as u128) >> 64) as u64;
            let mut res = (x >> 64) as u64 + self.m - a;
            if res >= self.m {
                res -= self.m;
            }
            res as u64
        }
        pub fn reduce(&self, x: u64) -> u64 {
            self.reduce_double(x as u128)
        }

        pub fn transform(&self, x: u64) -> u64 {
            debug_assert!(x < self.m);
            self.mul(x, self.r2)
        }
    }

    impl ModOp<u64> for Montgomery<u64> {
        fn zero(&self) -> u64 {
            0
        }

        fn one(&self) -> u64 {
            self.transform(1)
        }

        fn modulus(&self) -> u64 {
            self.m
        }

        fn mul(&self, x: u64, y: u64) -> u64 {
            debug_assert!(x < self.m);
            debug_assert!(y < self.m);
            self.reduce_double(x as u128 * y as u128)
        }

        fn add(&self, x: u64, y: u64) -> u64 {
            debug_assert!(x < self.m);
            debug_assert!(y < self.m);
            let sum = x + y;
            if sum >= self.m {
                sum - self.m
            } else {
                sum
            }
        }

        fn sub(&self, x: u64, y: u64) -> u64 {
            debug_assert!(x < self.m);
            debug_assert!(y < self.m);
            if x >= y {
                x - y
            } else {
                x + self.m - y
            }
        }
    }
}

const P: u128 = 1_000_000_000_000_000_031;

fn f_inv(mont: &Montgomery<u64>, x: u64) -> u64 {
    mont.reduce(mont.pow(mont.transform(42), x))
}

fn f_inv_k(mont: &Montgomery<u64>, x: u64, k: u32) -> u64 {
    let mut x = x;
    for _ in 0..k {
        x = f_inv(mont, x);
    }
    x
}

fn solve_naive(mont: &Montgomery<u64>, n: u32) -> u64 {
    let n1 = 1000000;
    let y1: u64 = 300;

    assert!(n <= n1);
    f_inv_k(mont, y1, n1 - n)
}

fn gen_breakpoints(mont: &Montgomery<u64>, n_data: u32) -> Vec<(u32, u64)> {
    let n1 = 1000000;
    let step = n1 / n_data;

    let mut y = 300;
    let mut res = vec![(n1, y)];
    for n in 1..=n1 {
        y = f_inv(mont, y);
        if n % step == 0 {
            res.push((n1 - n, y));
        }
    }
    res
}

fn precomputed_breakpoints() -> &'static [(u32, u64)] {
    &[
        (1000000, 300),
        (998000, 690364217800550799),
        (996000, 379090644732019526),
        (994000, 876898713572681746),
        (992000, 727803018629322868),
        (990000, 604523093747609877),
        (988000, 904935194638229823),
        (986000, 415469970341921580),
        (984000, 185729659439760518),
        (982000, 279068816040703147),
        (980000, 263664213679349194),
        (978000, 822628161267488108),
        (976000, 119239635260801141),
        (974000, 788148476012850536),
        (972000, 51586240826471702),
        (970000, 111177710689769374),
        (968000, 511699661748307010),
        (966000, 145464167365993365),
        (964000, 831549540500499203),
        (962000, 338731105487548597),
        (960000, 16207142242903127),
        (958000, 257632932528461173),
        (956000, 46017571811269552),
        (954000, 757237436969722183),
        (952000, 242072386762684451),
        (950000, 398008474269027903),
        (948000, 78368217623958870),
        (946000, 979018150272478846),
        (944000, 872736045551061119),
        (942000, 576404746144549383),
        (940000, 552980484040496656),
        (938000, 759571186868032501),
        (936000, 640352395825501136),
        (934000, 983607125623702047),
        (932000, 596365501068804207),
        (930000, 490735970350438668),
        (928000, 831652006396593829),
        (926000, 849519020355913784),
        (924000, 416919351468968719),
        (922000, 502043028590777066),
        (920000, 332945420174562448),
        (918000, 760001266645121269),
        (916000, 126722485113024404),
        (914000, 675101821324336684),
        (912000, 698538856252338933),
        (910000, 981394973174872839),
        (908000, 386928111064954678),
        (906000, 405415115225490068),
        (904000, 308293435189976648),
        (902000, 522998704288579703),
        (900000, 595434813073510155),
        (898000, 470503956553863987),
        (896000, 293241578297797549),
        (894000, 839176312244414457),
        (892000, 100682748077028910),
        (890000, 603399447217683132),
        (888000, 506169548728700763),
        (886000, 424579548026187206),
        (884000, 229554125572011001),
        (882000, 328822104517290043),
        (880000, 45357249881989340),
        (878000, 459182509634523384),
        (876000, 424556264088450463),
        (874000, 909672526509716683),
        (872000, 59446002674573758),
        (870000, 217535446095331222),
        (868000, 345580220619006613),
        (866000, 898241236304870037),
        (864000, 577754803323287261),
        (862000, 683044920376463286),
        (860000, 402888495712642935),
        (858000, 6640848233494732),
        (856000, 658984771059860610),
        (854000, 762089861137830993),
        (852000, 135086211217076364),
        (850000, 429557934954173370),
        (848000, 847185649342506461),
        (846000, 797957840797787993),
        (844000, 755213767670333857),
        (842000, 205073189988601404),
        (840000, 360638505716448478),
        (838000, 215049018501918521),
        (836000, 567836723373800173),
        (834000, 624170469001572295),
        (832000, 262605493671790673),
        (830000, 790816736815687209),
        (828000, 274617113670799358),
        (826000, 175343051421943234),
        (824000, 103085829951175164),
        (822000, 594759450588261823),
        (820000, 170658988254339141),
        (818000, 74531861346377014),
        (816000, 841411303680801655),
        (814000, 800138263385392949),
        (812000, 638266451370423668),
        (810000, 823416088365325399),
        (808000, 882732614231101391),
        (806000, 209305605177512671),
        (804000, 130386744119985514),
        (802000, 828274732587190201),
        (800000, 953868188743351784),
        (798000, 963258607124896376),
        (796000, 439109170854689510),
        (794000, 386931725810749262),
        (792000, 697418444105588412),
        (790000, 478234167891995446),
        (788000, 506235884860196659),
        (786000, 664968025072925142),
        (784000, 684614612506466586),
        (782000, 746243038464872107),
        (780000, 229663218988826955),
        (778000, 922562502175962637),
        (776000, 906738366311047396),
        (774000, 675076541078645525),
        (772000, 520937654310611391),
        (770000, 862776759928778342),
        (768000, 340403447831163660),
        (766000, 32019792491616471),
        (764000, 321966278982277126),
        (762000, 575044486767804677),
        (760000, 722463790695460179),
        (758000, 587053087059702653),
        (756000, 484301321909378873),
        (754000, 102942256084447791),
        (752000, 405705916809416446),
        (750000, 710513446719875515),
        (748000, 690923017309294373),
        (746000, 688724848224070365),
        (744000, 147648628442364613),
        (742000, 221649353429334265),
        (740000, 888479016514582050),
        (738000, 673318672649467797),
        (736000, 964296457181288017),
        (734000, 433435828861316776),
        (732000, 115962843303719890),
        (730000, 56102265683183681),
        (728000, 726915018064265453),
        (726000, 100814517532448635),
        (724000, 970321735697541355),
        (722000, 480480611777930002),
        (720000, 694010925620212010),
        (718000, 500254801672697530),
        (716000, 560916767495114763),
        (714000, 806330820773729687),
        (712000, 401872794918743615),
        (710000, 549394012674625115),
        (708000, 476584799072568466),
        (706000, 559173681441251517),
        (704000, 504867606097148263),
        (702000, 183672637838553170),
        (700000, 182088490368690869),
        (698000, 885582625752184489),
        (696000, 170916708311530988),
        (694000, 49845903869467609),
        (692000, 998779525762374030),
        (690000, 305197319061821716),
        (688000, 974178286738473520),
        (686000, 446456018364581052),
        (684000, 779581794108187396),
        (682000, 508422595389546641),
        (680000, 811390792779032911),
        (678000, 646661206719049933),
        (676000, 957771314670000936),
        (674000, 519905411534070408),
        (672000, 751573040341190128),
        (670000, 770360372781697878),
        (668000, 837620735921437743),
        (666000, 752900287118623336),
        (664000, 745649195005667890),
        (662000, 421158297927680440),
        (660000, 828513670683248979),
        (658000, 585707504906033161),
        (656000, 630518583694177636),
        (654000, 796040950519711726),
        (652000, 583082267206342750),
        (650000, 762480669174518701),
        (648000, 480053447974059734),
        (646000, 270908295995747638),
        (644000, 863863655043689938),
        (642000, 580133882393296957),
        (640000, 811943454972855043),
        (638000, 455735821059680833),
        (636000, 811645380150054976),
        (634000, 274465730936354076),
        (632000, 256945938889984388),
        (630000, 360429287809462089),
        (628000, 367357022530817440),
        (626000, 648715741097508606),
        (624000, 530394835887732602),
        (622000, 941432995844729995),
        (620000, 994954321424973183),
        (618000, 653860068251188715),
        (616000, 413154203808068357),
        (614000, 747530675087909855),
        (612000, 728132314775764155),
        (610000, 674945659005817725),
        (608000, 312910924471683322),
        (606000, 203878293374222062),
        (604000, 549414476971499338),
        (602000, 204662841710819366),
        (600000, 676329851857085630),
        (598000, 7250532043053476),
        (596000, 579495495988950094),
        (594000, 865305234782314391),
        (592000, 697533588713564652),
        (590000, 704105338813677194),
        (588000, 85574426626184726),
        (586000, 414823793447859489),
        (584000, 586375687819769194),
        (582000, 129983544750675494),
        (580000, 869721859189060487),
        (578000, 300437575971138288),
        (576000, 983559841839680220),
        (574000, 683955713716433143),
        (572000, 134794053344117577),
        (570000, 402425907539383253),
        (568000, 2181215965338227),
        (566000, 133621525256271697),
        (564000, 42457423471304186),
        (562000, 532204425188710671),
        (560000, 398809378873795083),
        (558000, 872589969964269748),
        (556000, 619342988431453655),
        (554000, 387032752665890460),
        (552000, 754628941506692518),
        (550000, 422763519175876093),
        (548000, 654493478280225314),
        (546000, 115469919875134778),
        (544000, 426539536896165518),
        (542000, 331426265208209499),
        (540000, 433781283252929254),
        (538000, 592477725019868250),
        (536000, 704817500612583949),
        (534000, 592120301705622530),
        (532000, 55917623583132841),
        (530000, 774330732328310094),
        (528000, 178921203378066602),
        (526000, 482835796201331734),
        (524000, 42402674485382899),
        (522000, 641518492003130551),
        (520000, 851734977106785568),
        (518000, 571546584947245636),
        (516000, 147084570616343964),
        (514000, 831169627875397742),
        (512000, 756244699125922958),
        (510000, 168229819992553512),
        (508000, 397194008142051236),
        (506000, 128962821546000317),
        (504000, 863048334025818106),
        (502000, 996874365720318630),
        (500000, 867291824898320635),
        (498000, 457333407398749874),
        (496000, 749164437622241036),
        (494000, 896286937203617656),
        (492000, 299799128268979226),
        (490000, 52937792117607997),
        (488000, 599656104421801289),
        (486000, 630379893880737362),
        (484000, 662286470598653288),
        (482000, 668791015981498415),
        (480000, 61556124552404517),
        (478000, 476543030403073165),
        (476000, 172556146797620078),
        (474000, 322197078032547932),
        (472000, 595527584058855275),
        (470000, 479674048896169835),
        (468000, 231201405341893873),
        (466000, 341161112227778776),
        (464000, 877808602580921176),
        (462000, 325685448051822531),
        (460000, 620170519834272434),
        (458000, 81707606696386902),
        (456000, 827883904915768040),
        (454000, 772946257281572352),
        (452000, 680568523188694911),
        (450000, 399553563234994000),
        (448000, 613344496259055037),
        (446000, 343983413086056492),
        (444000, 382557943437134833),
        (442000, 528034514278658734),
        (440000, 580925135878641758),
        (438000, 369780840028905801),
        (436000, 564578455283297164),
        (434000, 516074353973790026),
        (432000, 469525084831214887),
        (430000, 586522179823668356),
        (428000, 766644266330637071),
        (426000, 601308590573330921),
        (424000, 754617385186224784),
        (422000, 124756511119848728),
        (420000, 459975591602241119),
        (418000, 822314491516508207),
        (416000, 546882045907451085),
        (414000, 59547794636276892),
        (412000, 451193988192996940),
        (410000, 57560412081968579),
        (408000, 965888828569313327),
        (406000, 967444740955964465),
        (404000, 49981550065283543),
        (402000, 237202952480361259),
        (400000, 631636609111605552),
        (398000, 2641698713835215),
        (396000, 17885327511009934),
        (394000, 809811224634584390),
        (392000, 471740534960244484),
        (390000, 150897366893931532),
        (388000, 63622213483001913),
        (386000, 835719770894999440),
        (384000, 51391030730077291),
        (382000, 113200273037301176),
        (380000, 739456965060176426),
        (378000, 904548943450826614),
        (376000, 347428813673482449),
        (374000, 622890610097071266),
        (372000, 658516123021106896),
        (370000, 119365924919555544),
        (368000, 279407381606829322),
        (366000, 397992306360746510),
        (364000, 432797113186464040),
        (362000, 292032575666916006),
        (360000, 985120228627553732),
        (358000, 636308000035384697),
        (356000, 951618063828800018),
        (354000, 341924513836503091),
        (352000, 194782875330994517),
        (350000, 389658766579572395),
        (348000, 912489405641702808),
        (346000, 678686509513980360),
        (344000, 290697525897267777),
        (342000, 112480296026115886),
        (340000, 611663364027090969),
        (338000, 797478193175575565),
        (336000, 851246618819085976),
        (334000, 616502630910882174),
        (332000, 141777580526447871),
        (330000, 887871107614642589),
        (328000, 376431296723788308),
        (326000, 10940926681308821),
        (324000, 481300873514125828),
        (322000, 441369986816495264),
        (320000, 166551241254184076),
        (318000, 13785291770066335),
        (316000, 26568890131741966),
        (314000, 987212219248801451),
        (312000, 821822482487131307),
        (310000, 815054554531228395),
        (308000, 568780316716267384),
        (306000, 820086169856408380),
        (304000, 471925590692983993),
        (302000, 556932413672366836),
        (300000, 288608327947425062),
        (298000, 946122294446567824),
        (296000, 627535708153929415),
        (294000, 343864148532096711),
        (292000, 36116372429357343),
        (290000, 908961589463131373),
        (288000, 362593673170579888),
        (286000, 346607695334796503),
        (284000, 133808798176717303),
        (282000, 77367882343872118),
        (280000, 793251140479321996),
        (278000, 323386109291129486),
        (276000, 702601407092841500),
        (274000, 123089855866146850),
        (272000, 191411001072509897),
        (270000, 720288883206795968),
        (268000, 205379708000290572),
        (266000, 352186168388305525),
        (264000, 449619777073353959),
        (262000, 959498461647708587),
        (260000, 874432076663395693),
        (258000, 855928934672270625),
        (256000, 37855196471258332),
        (254000, 191474458636053755),
        (252000, 42734293067559027),
        (250000, 295379185775399294),
        (248000, 754969444659143485),
        (246000, 562914791054606009),
        (244000, 103672576014057612),
        (242000, 815497018714612156),
        (240000, 340618233145230920),
        (238000, 849484296291157558),
        (236000, 241400953112671433),
        (234000, 795155890089338862),
        (232000, 505623557566640321),
        (230000, 535534634316248421),
        (228000, 326141042705446523),
        (226000, 111198150832296467),
        (224000, 847763691569290694),
        (222000, 896296330003254212),
        (220000, 266233584003280291),
        (218000, 346731999960420722),
        (216000, 957661936077149783),
        (214000, 459130255830289341),
        (212000, 897696837585857838),
        (210000, 426548092512553817),
        (208000, 386147488828804270),
        (206000, 538739051099477075),
        (204000, 772526000706835965),
        (202000, 610272761835904968),
        (200000, 689228462019985506),
        (198000, 242569261793653687),
        (196000, 169617586623242618),
        (194000, 248069472528596678),
        (192000, 946890608107196882),
        (190000, 448599518176134256),
        (188000, 324418604734703313),
        (186000, 241933593475239972),
        (184000, 296893207178863970),
        (182000, 375576282346740424),
        (180000, 472704627847770069),
        (178000, 682495641851028631),
        (176000, 186202519959751879),
        (174000, 217704338046015588),
        (172000, 708257169677184257),
        (170000, 298512486213598808),
        (168000, 459851584999571519),
        (166000, 496096820417653094),
        (164000, 60418977717997839),
        (162000, 537640743665422764),
        (160000, 853693463256577512),
        (158000, 454833536847448517),
        (156000, 426765306518402935),
        (154000, 259581114461033384),
        (152000, 652286021630585383),
        (150000, 863617053845631140),
        (148000, 251873498252936212),
        (146000, 716994465923505335),
        (144000, 170048890925484171),
        (142000, 205953777234790142),
        (140000, 113693876342444686),
        (138000, 611386618214491864),
        (136000, 437760984050394092),
        (134000, 863064842011901765),
        (132000, 184984105310499224),
        (130000, 206379139741059691),
        (128000, 450183137974527363),
        (126000, 790229537571657970),
        (124000, 72970618644772291),
        (122000, 180830124090524615),
        (120000, 840815609724411549),
        (118000, 614571090778268660),
        (116000, 718932254595819356),
        (114000, 769891644183303333),
        (112000, 624187926148682468),
        (110000, 998265740966665018),
        (108000, 722092171222741794),
        (106000, 973762630879207751),
        (104000, 287539944956219680),
        (102000, 30705377063534612),
        (100000, 360604945156726118),
        (98000, 844303599251767146),
        (96000, 588261728363808460),
        (94000, 649783640553188435),
        (92000, 302912169135446840),
        (90000, 847611058647241660),
        (88000, 803010988132885434),
        (86000, 445708378431051852),
        (84000, 373456374129465066),
        (82000, 914504198543099317),
        (80000, 549202743875275334),
        (78000, 142355359190844354),
        (76000, 374140821631515933),
        (74000, 654987320085779772),
        (72000, 489695946716301215),
        (70000, 718200580539550367),
        (68000, 374012891498797280),
        (66000, 470781145974127451),
        (64000, 301477213086668064),
        (62000, 89157359516282640),
        (60000, 836331452110377852),
        (58000, 536865321597591068),
        (56000, 529508241192328946),
        (54000, 626720058838279972),
        (52000, 131065468223092939),
        (50000, 53712798929363726),
        (48000, 524906976722537596),
        (46000, 866204236979049115),
        (44000, 974022126831999347),
        (42000, 20430448283945106),
        (40000, 11335205735931594),
        (38000, 128723465317783956),
        (36000, 133877982255261864),
        (34000, 202302506628736663),
        (32000, 979447877683931933),
        (30000, 269834414221419989),
        (28000, 262694694328779471),
        (26000, 824218696376102098),
        (24000, 149708456982473975),
        (22000, 203062612732288630),
        (20000, 84900470438240057),
        (18000, 566217176477637021),
        (16000, 32321190872347394),
        (14000, 904674395468597466),
        (12000, 706863695513102478),
        (10000, 951418076129152163),
        (8000, 54368955077555362),
        (6000, 369606192610210837),
        (4000, 504300654597204525),
        (2000, 250684625537552073),
        (0, 960002411612632915),
    ]
}

fn main() {
    let mut input = simple_io::stdin_at_once();
    let mut output = simple_io::stdout();

    let mont = Montgomery::<u64>::new(P as u64);

    let n = input.value();

    // let breakpoints = gen_breakpoints(&mont, 500);
    // println!("{:?}", breakpoints);
    // return;

    let breakpoints = precomputed_breakpoints();
    let (n0, y0) = breakpoints
        .iter()
        .rev()
        .find(|&&(n_base, _)| n_base >= n)
        .unwrap();
    let y = f_inv_k(&mont, *y0, n0 - n);

    write!(output, "{}", y).unwrap();
}
